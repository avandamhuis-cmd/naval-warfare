<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Naval Game Prototype</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#info { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif;}
#crosshair {position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:20px; color:white; user-select:none; pointer-events:none;}
</style>
</head>
<body>
<div id="info">Click to lock mouse. WASD move, SPACE jump/swim, Left Click fire, Right Click aim, R reload, 1 equip/unequip musket, E interact</div>
<div id="crosshair">+</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>

// --- Scene ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Player hierarchy ---
const yawObject = new THREE.Object3D();
const pitchObject = new THREE.Object3D();
pitchObject.add(camera);
yawObject.add(pitchObject);
scene.add(yawObject);
yawObject.position.set(0,1.8,5);

// --- Lights ---
const sun = new THREE.DirectionalLight(0xffffff,1.2);
sun.position.set(50,100,50);
scene.add(sun);
scene.add(new THREE.AmbientLight(0xffffff,0.6));
scene.add(new THREE.HemisphereLight(0x87ceeb,0x228B22,0.4));

// --- Water ---
const waterGeometry = new THREE.PlaneGeometry(400,400,100,100);
const waterMaterial = new THREE.MeshLambertMaterial({color:0x1E90FF, side:THREE.DoubleSide});
const water = new THREE.Mesh(waterGeometry, waterMaterial);
water.rotation.x=-Math.PI/2; water.position.y=-2; scene.add(water);
const waterPositions = water.geometry.attributes.position;

// --- Map boundaries ---
const boundaryMaterial = new THREE.MeshBasicMaterial({color:0xff0000, visible:false});
const boundaries = [
  new THREE.Mesh(new THREE.BoxGeometry(400,10,1), boundaryMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(400,10,1), boundaryMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(1,10,400), boundaryMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(1,10,400), boundaryMaterial)
];
boundaries[0].position.set(0,3,200);
boundaries[1].position.set(0,3,-200);
boundaries[2].position.set(-200,3,0);
boundaries[3].position.set(200,3,0);
boundaries.forEach(b=>{scene.add(b);});

// --- Collidables ---
const collidables = [];

// --- Irregular main island ---
const islandParts = [];
const islandMaterial = new THREE.MeshLambertMaterial({color:0x228B22});
const islandShape = [
  {x:0, z:0, w:12, d:8, h:2},
  {x:-5, z:3, w:6, d:4, h:2},
  {x:4, z:-4, w:5, d:6, h:2},
  {x:2, z:6, w:4, d:3, h:2}
];
islandShape.forEach(p=>{
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(p.w,p.h,p.d), islandMaterial);
  mesh.position.set(p.x,-1,p.z);
  scene.add(mesh); collidables.push(mesh); islandParts.push(mesh);
});

// --- Dock near island ---
const dockPlanks = [], dockPillars=[];
for(let i=-4;i<=4;i++){
  for(let j=0;j<3;j++){
    const plank=new THREE.Mesh(new THREE.BoxGeometry(1,0.3,2), new THREE.MeshLambertMaterial({color:0x8B4513}));
    plank.position.set(i*1.2,0,j*1.5-11); scene.add(plank); dockPlanks.push(plank); collidables.push(plank);
  }
}
for(let i=-4;i<=4;i++){
  for(let j=0;j<2;j++){
    const pillar=new THREE.Mesh(new THREE.BoxGeometry(0.3,2,0.3), new THREE.MeshLambertMaterial({color:0x654321}));
    pillar.position.set(i*1.2,-2+j*2,-11); scene.add(pillar); dockPillars.push(pillar); collidables.push(pillar);
  }
}

// --- Table + NPC ---
const table = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1.5), new THREE.MeshLambertMaterial({color:0x8B4513}));
table.position.set(3,0,-6); scene.add(table); collidables.push(table);
const npc = new THREE.Mesh(new THREE.BoxGeometry(1,2.5,1), new THREE.MeshLambertMaterial({color:0x0000FF}));
npc.position.set(3,1.25,-7); scene.add(npc); collidables.push(npc);

// --- Interaction text ---
const interactionText = document.createElement("div");
interactionText.style.position="absolute"; interactionText.style.color="white"; interactionText.style.fontFamily="sans-serif";
interactionText.style.fontSize="16px"; interactionText.style.top="50%"; interactionText.style.left="50%";
interactionText.style.transform="translate(-50%,-50%)"; interactionText.style.pointerEvents="none"; interactionText.style.display="none";
interactionText.innerText="Press E to interact"; document.body.appendChild(interactionText);

// --- Player ---
let player={height:1.8,speed:0.15,swimSpeed:0.07,jumpPower:0.25,yVelocity:0,isJumping:false,isSwimming:false};
let keys={}; document.addEventListener('keydown',e=>keys[e.code]=true); document.addEventListener('keyup',e=>keys[e.code]=false);

// --- Mouse ---
let mouseLocked=false;
document.body.addEventListener("click",()=>{if(!mouseLocked)document.body.requestPointerLock();});
document.addEventListener("pointerlockchange",()=>{mouseLocked=(document.pointerLockElement===document.body);});
document.addEventListener("mousemove",e=>{
  if(mouseLocked){
    yawObject.rotation.y -= e.movementX*0.002;
    pitchObject.rotation.x -= e.movementY*0.002;
    pitchObject.rotation.x=Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
  }
});

// --- Musket ---
let musketEquipped=true, ammo=1, isAiming=false, canShoot=true, isReloading=false;
const musket = new THREE.Object3D(); camera.add(musket);

// Steel barrel
const steelBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,1.2,16), new THREE.MeshLambertMaterial({color:0x444444}));
steelBarrel.rotation.x=Math.PI/2; steelBarrel.position.set(0,0,0.6); musket.add(steelBarrel);

// Wooden stock (brown)
const woodenStock = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,1.2,16), new THREE.MeshLambertMaterial({color:0x8B4513}));
woodenStock.rotation.x=Math.PI/2; woodenStock.position.set(0,-0.05,0.6); musket.add(woodenStock);

// Muzzle flash
const muzzleFlash = new THREE.Mesh(new THREE.SphereGeometry(0.04,8,8), new THREE.MeshBasicMaterial({color:0xffaa00}));
muzzleFlash.visible=false; muzzleFlash.position.set(0,0,1.2); musket.add(muzzleFlash);

// Smoke
const smoke = new THREE.Mesh(new THREE.SphereGeometry(0.07,8,8), new THREE.MeshBasicMaterial({color:0x888888,transparent:true,opacity:0.5}));
smoke.visible=false; smoke.position.set(0,0,1.2); musket.add(smoke);

// --- Bullets ---
let bullets=[];

// --- Ships ---
class Ship{
  constructor(pos){
    this.mesh=new THREE.Mesh(new THREE.BoxGeometry(2,0.5,4), new THREE.MeshLambertMaterial({color:0x654321}));
    this.mesh.position.copy(pos); scene.add(this.mesh); collidables.push(this.mesh);
    this.sinking=false; this.playerOnBoard=false; this.forward=new THREE.Vector3(0,0,1);
  }
  update(delta){
    if(this.sinking){
      this.mesh.rotation.x += delta*0.2; this.mesh.position.y -= delta*0.1;
      if(this.mesh.position.y < -2){
        scene.remove(this.mesh); collidables.splice(collidables.indexOf(this.mesh),1); ships.splice(ships.indexOf(this),1);
      }
      return;
    }
    if(!this.playerOnBoard) return;

    const moveVec = new THREE.Vector3();
    if(keys["KeyW"]) moveVec.add(this.forward.clone().multiplyScalar(0.1));
    if(keys["KeyS"]) moveVec.add(this.forward.clone().multiplyScalar(-0.05));

    // Tentative collision check
    const nextPos = this.mesh.position.clone().add(moveVec);
    let collision = false;
    for(let obj of collidables){
      if(obj===this.mesh) continue;
      const dist = nextPos.distanceTo(obj.position);
      const radius = 1.5;
      if(dist < radius){ collision=true; break; }
    }
    if(!collision) this.mesh.position.copy(nextPos);

    if(keys["KeyA"]) this.mesh.rotation.y += 0.02;
    if(keys["KeyD"]) this.mesh.rotation.y -= 0.02;
    this.forward.set(0,0,1).applyEuler(this.mesh.rotation);
  }
  destroy(){this.sinking=true; this.playerOnBoard=false;}
  enter(){this.playerOnBoard=true; yawObject.position.set(0,1.8,0); camera.position.set(0,1.8,0);}
  exit(){this.playerOnBoard=false; yawObject.position.copy(this.mesh.position.clone().add(new THREE.Vector3(3,0,0))); currentShip=null;}
}
let ships=[],currentShip=null;

// --- Player gold ---
let playerGold=100;

// --- Raycaster ---
const raycaster=new THREE.Raycaster();

// --- Fire / reload ---
function fireMusket(){ if(!canShoot||isReloading||!musketEquipped||ammo<=0) return; ammo--; muzzleFlash.visible=true; smoke.visible=true; setTimeout(()=>{muzzleFlash.visible=false;},150); spawnBullet();}
function reloadMusket(){if(isReloading||!musketEquipped) return; isReloading=true; setTimeout(()=>{ammo=1; isReloading=false;},7000);}
document.addEventListener("mousedown",e=>{if(e.button===0)fireMusket(); if(e.button===2) isAiming=true;});
document.addEventListener("mouseup",e=>{if(e.button===2) isAiming=false;});
document.addEventListener("contextmenu", e => e.preventDefault());
document.addEventListener("keydown", e => { 
  if(e.code==="KeyR") reloadMusket(); 
  if(e.code==="Digit1") musketEquipped = !musketEquipped; 
});

// --- Spawn bullet ---
function spawnBullet(){
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.05,8,8),
    new THREE.MeshLambertMaterial({color:0x888888})
  );
  const tip = new THREE.Vector3(); steelBarrel.getWorldPosition(tip);
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  bullet.position.copy(tip).add(dir.clone().multiplyScalar(0.1));
  bullet.userData = { velocity: dir.clone().multiplyScalar(1), spawnTime: performance.now() };
  scene.add(bullet); bullets.push(bullet);
}

// --- NPC interaction ---
let npcInRange=false;
function checkNPCInteraction(){
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  raycaster.set(camera.getWorldPosition(new THREE.Vector3()), dir);
  const intersects = raycaster.intersectObject(npc);
  const distance = yawObject.position.distanceTo(npc.position);
  if(intersects.length > 0 && distance < 3){
    interactionText.style.display = "block";
    interactionText.innerText = "Press E to open market";
    npcInRange = true;
  } else {
    npcInRange = false;
  }
}

// --- Market ---
function openMarket(){ 
  const buy = confirm("Buy a small ship for 50 gold?");
  if(buy && playerGold >= 50){ 
    playerGold -= 50; 
    spawnShipNearDock(); 
    alert("Ship purchased! Remaining gold: "+playerGold);
  } else if(buy) alert("Not enough gold!");
}
function spawnShipNearDock(){ 
  const ship = new Ship(new THREE.Vector3(5,0,-9)); 
  ships.push(ship);
}

// --- Ship interactions ---
let ePressed = false;
document.addEventListener("keydown", (e) => {
  if(e.code === "KeyE" && !ePressed){
    ePressed = true;
    if(npcInRange) openMarket();
    else checkShipBoarding();
  }
});
document.addEventListener("keyup", (e) => { if(e.code==="KeyE") ePressed=false; });

function checkShipBoarding(){
  let nearShip=false;
  for(let ship of ships){
    const distance = yawObject.position.distanceTo(ship.mesh.position);
    if(distance<3){
      nearShip=true;
      if(currentShip !== ship){ currentShip = ship; ship.enter(); }
      else { ship.exit(); currentShip=null; }
      break;
    }
  }
  if(!nearShip && !npcInRange) interactionText.style.display="none";
  else if(nearShip) interactionText.style.display="block";
}

// --- Update bullets ---
function updateBullets(delta){
  const now = performance.now();
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i]; 
    b.position.add(b.userData.velocity.clone().multiplyScalar(delta*60));
    let hit = false;
    for(let obj of collidables){
      const r = 0.05 + (obj.geometry.boundingSphere?.radius || 1);
      if(b.position.distanceTo(obj.position)<r){
        hit = true;
        if(ships.find(s=>s.mesh===obj)){ ships.find(s=>s.mesh===obj).destroy(); }
        break;
      }
    }
    if(hit || now - b.userData.spawnTime > 3000){ scene.remove(b); bullets.splice(i,1); }
  }
}

// --- Animate ---
function animate(){
  requestAnimationFrame(animate);
  const delta = 0.016;
  const time = Date.now()*0.001;

  // Water waves
  for(let i=0;i<waterPositions.count;i++){
    const x=waterPositions.getX(i), y=waterPositions.getY(i);
    waterPositions.setZ(i, Math.sin(x*0.1+time)*0.15 + Math.cos(y*0.1+time)*0.15);
  }
  waterPositions.needsUpdate = true;

  // Movement
  let move = new THREE.Vector3(); 
  if(keys["KeyW"]) move.z -= 1; 
  if(keys["KeyS"]) move.z += 1; 
  if(keys["KeyA"]) move.x -= 1; 
  if(keys["KeyD"]) move.x += 1; 
  move.normalize();
  player.isSwimming = (yawObject.position.y < water.position.y + 0.3);
  if(player.isSwimming){
    yawObject.translateX(move.x*player.swimSpeed);
    yawObject.translateZ(move.z*player.swimSpeed);
    player.yVelocity=Math.sin(time*3)*0.01;
    if(keys["Space"]){ player.yVelocity=player.jumpPower; player.isSwimming=false; }
  } else {
    yawObject.translateX(move.x*player.speed);
    yawObject.translateZ(move.z*player.speed);
    if(yawObject.position.y>player.height) player.yVelocity -= 0.015; 
    else { yawObject.position.y=player.height; player.yVelocity=0; player.isJumping=false; }
    if(keys["Space"] && yawObject.position.y <= player.height+0.01){ player.yVelocity=player.jumpPower; player.isJumping=true; }
  }
  yawObject.position.y += player.yVelocity;

  // Musket
  let targetPos = musketEquipped ? (isAiming ? new THREE.Vector3(0,-0.05,-0.6) : new THREE.Vector3(0,-0.2,-0.8)) : new THREE.Vector3(0,0.5,0.3);
  musket.position.lerp(targetPos,0.1);

  // Smoke fade
  if(smoke.visible){ smoke.material.opacity -= 0.01; if(smoke.material.opacity<=0) smoke.visible=false; }

  // Interactions
  checkNPCInteraction();
  checkShipBoarding();

  // Bullets
  updateBullets(delta);

  // Ships
  for(let ship of ships) ship.update(delta);

  renderer.render(scene,camera);
}
animate();

// --- Resize ---
window.addEventListener("resize",()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

</script>
</body>
</html>
